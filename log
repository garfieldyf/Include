1．pop、push、getMin 操作的时间复杂度都是 O(1)。
2. 如何仅用递归函数和栈操作逆序一个栈
public static int getAndRemoveLastElement(Stack<Integer> stack) {
    int result = stack.pop();
    if (stack.isEmpty()) {
        return result;
    } else {
        int last = getAndRemoveLastElement(stack);
        stack.push(result);
        return last;
    }
}

public static void reverse(Stack<Integer> stack) {
    if (stack.isEmpty()) {
        return;
    }

    int i = getAndRemoveLastElement(stack);
    reverse(stack);
    stack.push(i);
}

3. 在单链表和双链表中删除倒数第 K 个节点
public class Node {
    public int value;
    public Node next;

    public Node(int data) {
        this.value = data;
    }
}

public Node removeLastKthNode(Node head, int lastKth) {
    if (head == null || lastKth < 1) {
        return head;
    }

    Node cur = head;
    while (cur != null) {
        lastKth--;
        cur = cur.next;
    }
    
    if (lastKth == 0) {
        head = head.next;
    }
    
    if (lastKth < 0) {
        cur = head;
        while (++lastKth != 0) {
            cur = cur.next;
        }

        cur.next = cur.next.next;
    }

    return head;
}

public class DoubleNode {
    public int value;
    public DoubleNode last;
    public DoubleNode next;

    public DoubleNode(int data) {
        this.value = data;
    }
}
public DoubleNode removeLastKthNode(DoubleNode head, int lastKth) {
    if (head == null || lastKth < 1) {
        return head;
    }

    DoubleNode cur = head;
    while (cur != null) {
        lastKth--;
        cur = cur.next;
    }

    if (lastKth == 0) {
        head = head.next;
        head.last = null;
    }

    if (lastKth < 0) {
        cur = head;
        while (++lastKth != 0) {
            cur = cur.next;
        }

        DoubleNode newNext = cur.next.next;
        cur.next = newNext;
        if (newNext != null) {
            newNext.last = cur;
        }
    }

    return head;
}

public Node removeMidNode(Node head) {
    if (head == null || head.next == null) {
        return head;
    }

    if (head.next.next == null) {
        return head.next;
    }

    Node pre = head;
    Node cur = head.next.next;
    while (cur.next != null && cur.next.next != null) {
        pre = pre.next;
        cur = cur.next.next;
    }

    pre.next = pre.next.next;
    return head;
}

public boolean isPalindrome3(Node head) {
    if (head == null || head.next == null) {
        return true;
    }

    Node n1 = head;
    Node n2 = head;

    while (n2.next != null && n2.next.next != null) { // 查找中间节点
        n1 = n1.next; // n1 -> 中部
        n2 = n2.next.next; // n2 -> 结尾
    }

    n2 = n1.next; // n2 -> 右部分第一个节点
    n1.next = null; // mid.next -> null
    Node n3 = null;

    while (n2 != null) { // 右半区反转
        n3 = n2.next; // n3 -> 保存下一个节点
        n2.next = n1; // 下一个反转节点
        n1 = n2; // n1 移动
        n2 = n3; // n2 移动
    }

    n3 = n1; // n3 -> 保存最后一个节点
    n2 = head;// n2 -> 左边第一个节点
    boolean res = true;

    while (n1 != null && n2 != null) { // 检查回文
        if (n1.value != n2.value) {
            res = false;
            break;
        }

        n1 = n1.next; // 从左到中部
        n2 = n2.next; // 从右到中部
    }

    n1 = n3.next;
    n3.next = null;

    while (n1 != null) { // 恢复列表
        n2 = n1.next;
        n1.next = n3;
        n3 = n1;
        n1 = n2;
    }

    return res;
}